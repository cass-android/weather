<!DOCTYPE html>
<html>
<head lang="en">
<meta charset="UTF-8">
<title>Weather Dashboard</title>
<style>
* {
  font-family: Arial, Helvetica, sans-serif;
}
.header{
  background-color: #FFFFFF;
  margin: 0px 25px 0px 40px;
  overflow: hidden;
  height: 5%;
}
ul li{ 
  margin-bottom: 10px; 
}
body{
  margin-left: 100px;
  margin-right: 100px;

}
p {
  text-align: justify;
}

</style>
</head>
<body>
  
<div class="Header">
  <h1> Building a Data-Driven App with Flask and Postgres </h1>
  <a href="/"style="float:right">Back to Main Page</a>
</div> 

  <h2> Overview </h2>
  <p> Apart from reinforcing the known fact that weather forecasts are not very reliable, the goal of this project was to demonstrate a simple cloud-hosted application that can query an API, interact with a database through an ORM, and can display up-to-date information. In those regards it was primarily a learning exercise, aimed at getting past that initial hurdle of figuring out how pieces fit together.</p>

  <h2> Scope </h2>
  The project had its origins in other work involving weather data (e.g archiving bulk historical data from <a href="https://weather.gc.ca/mainmenu/weather_menu_e.html"> the Government of Canada</a>). My data model quickly narrowed down from 'all the weather everywhere' to just the Toronto temperature forecasts and recent actuals. I wanted to build something with some back-end automation and a cool dashboard. So I followed a question that was interesting to me, to what extent and how often does the weather forecast change.  intuitive way to visualize the actual predictive power of any  time-series forecast that is purported to be highly accurate. <p>

  <h2> Building an Application </h2>
  <p> Although <a href="https://dev.to/gypsydave5/why-you-shouldnt-use-a-web-framework-3g24"target="_blank"> there will always be naysayers, </a> a framework is generally a good starting point for building a web app. Since I alread had some work done in Python, I looked to Flask and Django (the best-known Python frameworks). Django can quickly generate a robust application with many utilities out of the box. Flask is much more minimalist and open-ended, leaving it up to the developer to structure the app and include additional packages as needed. I opted for Flask since Django seemed like overkill. </p>

  <p> As a site note, other (and potentially more powerful) Python frameworks abound. Applications making use of<a href= "https://hackernoon.com/a-simple-introduction-to-pythons-asyncio-595d9c9ecf8c"target="_blank">asyncio</a>, for example, would have to go beyond what Flask or Django can offer. However, both Flask and Django have been around a while and have plentiful support and documentation. Specific to analytic apps, <a href='https://plot.ly/products/dash/'target="_blank"> Plotly Dash </a> is a framework that minimizes the need for javascript. I used the Plotly library within my Flask app to create the plot itself, but alongside html/css/javascript for more control and flexibility on the front end. </p>


  <h2>File Structure</h2>
  <p>Flask is structure-neutral, meaning that apps can be anything from a single module to a large package. After a minor amount of confusion and restructuring, dividing my code into the following files seemed to work best: </p>

  <ul>
  	<li><b>main.py: </b> basically the ‘on’ switch that launches the app. A lot of examples I looked at included this within the app.py file. This was causing circularity problems for me, since app.py is imported by a number of other modules. The best solution seemed to be including it in a separate file. </li>

  	<li><b>app.py: </b> the module that contains the Flask instance and the database. I started thinking of this as the brain stem of the app, while main.py is the actual spark of consciousness. </li>

  	<li><b>models.py: </b> where the data models live. Here we define classes that create model objects representing the tables in our relational database. We can then interact with our database through these model objects. Models are created as children of the Model class in the Flask-SQLAlchemy extension. </li>

  	<li><b>config.py: </b> configures environment variables for deployment. This is determined by another variable, 'APP SETTINGS', that pulls the database URI and secret key from the os. This will be important when deploying to the cloud. The config file also sets some variables separately for development, staging and production environments -- probably overkill here, but nice to be aware of. 

  	<li><b>manage.py: </b> configures app, creates and runs migration files (used when you need to make changes to your database)</li>

  	<li><b>views.py: </b> handles requests and defines functions that render the templates, as well as passing them relevant variables (the JSON-ified plot data)  

  	<li><b>index.html: </b> the files that get rendered by views.py when a GET or POST request is recieved. The main challenge here was the drop-down menu. Each menu option is associated with a different function in my 'views.py', so the template is rendered with a totally different plot each time. The other option was the dropdown functionality within Plotly, but this requires all the data to be loaded at once, and then filtered on the page itself (based on a list of booleans). This would have been cumbersome to code since I have a large number of traces on the same plot. My solution also allows me to limit the amount of data that's loaded each time, for optimization of loading time vs. pretty graphs. 
  	</li>

  </ul>

  <h2> Analysis </h2>
  One consistent observation is that the forecast values all seem to lag the actual temperature changes. It is unclear whether this is an artifact, or indicative of a <a href="https://towardsdatascience.com/how-not-to-use-machine-learning-for-time-series-forecasting-avoiding-the-pitfalls-19f9d7adf424"target="_blank"target="_blank">persistence model </a>, or whether we've just been having unusually warm mornings recently.



  </p>  
</div>
</body>